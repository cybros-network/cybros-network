#![cfg_attr(not(feature = "std"), no_std)]

#[cfg(feature = "std")]
use std::fmt;

use frame_support::{
	codec::{Decode, Encode, MaxEncodedLen},
	scale_info::TypeInfo,
	sp_std::prelude::*,
	traits::ConstU32,
	BoundedVec,
	RuntimeDebug,
};

pub const ATTESTATION_ISSUED_PERIOD_OF_VALIDITY: u64 = 60 * 60 * 1000; // 1 hour

pub const MAX_ATTESTATION_PAYLOAD_SIZE: u32 = 64 * 1000; // limit to 64KB
pub const MAX_CUSTOM_PAYLOAD_SIZE: u32 = 64 * 1000; // limit to 64KB

pub type WorkerImplName = [u8; 4];
pub type WorkerImplVersion = u32;
pub type WorkerImplHash = BoundedVec<u8, ConstU32<64>>;

pub type AttestationPayload = BoundedVec<u8, ConstU32<MAX_ATTESTATION_PAYLOAD_SIZE>>;
pub type ExtraOnlinePayload = BoundedVec<u8, ConstU32<MAX_CUSTOM_PAYLOAD_SIZE>>;

#[derive(Encode, Decode, Clone, PartialEq, RuntimeDebug, TypeInfo, MaxEncodedLen)]
pub struct NonTEEAttestation {
	pub issued_at: u64,
	pub payload: AttestationPayload,
}

/// The type of how the worker do attestation
#[derive(Encode, Decode, Clone, PartialEq, Eq, RuntimeDebug, TypeInfo, MaxEncodedLen)]
pub enum AttestationMethod {
	/// Attest by dev mode
	NonTEE,
	/// Attest by root authority
	Root,
	// TODO: Intel SGX (EPID, ECDSA), AMD SEV, etc.
}

#[derive(Encode, Decode, TypeInfo, Debug, Clone, PartialEq, Eq)]
pub enum AttestationError {
	Invalid,
	Expired,
}

/// Worker's attestation
#[derive(Encode, Decode, Clone, PartialEq, RuntimeDebug, TypeInfo, MaxEncodedLen)]
pub enum Attestation {
	NonTEE(NonTEEAttestation),
	// TODO: Intel SGX (EPID, ECDSA), AMD SEV, etc.
}
impl Attestation {
	pub fn method(&self) -> AttestationMethod {
		match self {
			Attestation::NonTEE(..) => AttestationMethod::NonTEE,
		}
	}

	pub fn impl_hash(&self) -> WorkerImplHash {
		match self {
			Attestation::NonTEE(..) => WorkerImplHash::default(),
		}
	}

	pub fn verify(&self, now: u64) -> Result<VerifiedAttestation, AttestationError> {
		match self {
			Attestation::NonTEE(attestation) =>
				verify_non_tee_attestation(attestation, now).map(|_| Ok(VerifiedAttestation(self)))?,
		}
	}

	pub(self) fn payload(&self) -> &[u8] {
		match self {
			Attestation::NonTEE(attestation) => attestation.payload.as_slice(),
		}
	}
}

#[derive(Clone, PartialEq, RuntimeDebug)]
pub struct VerifiedAttestation<'a>(&'a Attestation);
impl VerifiedAttestation<'_> {
	pub fn method(&self) -> AttestationMethod {
		self.0.method()
	}

	pub fn impl_hash(&self) -> WorkerImplHash {
		self.0.impl_hash()
	}

	pub fn payload(&self) -> &[u8] {
		self.0.payload()
	}
}

fn verify_non_tee_attestation(attestation: &NonTEEAttestation, now: u64) -> Result<(), AttestationError> {
	let period = now - attestation.issued_at;
	if period > ATTESTATION_ISSUED_PERIOD_OF_VALIDITY {
		Err(AttestationError::Expired)
	} else {
		Ok(())
	}
}

#[derive(Encode, Decode, Clone, PartialEq, Eq, RuntimeDebug, TypeInfo, MaxEncodedLen)]
pub struct OnlinePayload {
	pub impl_name: WorkerImplName,
	pub impl_version: WorkerImplVersion,
	pub extra: ExtraOnlinePayload,
}

/// Worker's status
#[derive(Encode, Decode, Copy, Clone, PartialEq, Eq, RuntimeDebug, TypeInfo, MaxEncodedLen)]
pub enum WorkerStatus {
	/// Initial status for a new registered worker.
	Registered,
	/// The worker is online so it can accept job
	/// Transit from `Registered` and `Offline`,
	/// not sure for `RequestingOffline` (may have side effect)
	Online,
	/// The worker is requesting offline,
	/// the worker won't accept new job, accepted jobs will still processing,
	/// when accepted jobs processed it can be transited to `Offline` safely without slashing.
	/// Transit from `Online`
	RequestingOffline,
	/// The worker is offline so it can't accept job.
	/// Transit from `RequestingOffline` when job queue cleared,
	/// and `Online` (when force by user or be slashed)
	Offline,
}

impl Default for WorkerStatus {
	fn default() -> Self {
		WorkerStatus::Registered
	}
}

#[cfg(feature = "std")]
impl fmt::Display for WorkerStatus {
	fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
		match self {
			WorkerStatus::Registered => write!(f, "Registered"),
			WorkerStatus::Online => write!(f, "Online"),
			WorkerStatus::RequestingOffline => write!(f, "RequestingOffline"),
			WorkerStatus::Offline => write!(f, "Offline"),
		}
	}
}

/// Worker's info.
#[derive(Encode, Decode, MaxEncodedLen, TypeInfo, RuntimeDebug, Clone, PartialEq, Eq)]
#[scale_info(skip_type_params(T))]
pub struct WorkerInfo<AccountId, Balance, BlockNumber> {
	/// Account that generated by the worker app, used for identity the worker and send extrinsic.
	/// This field is readonly once set
	pub account: AccountId,
	/// Account that owning the worker.
	/// This field is readonly once set
	pub owner: AccountId,
	/// Reserved balance on register.
	/// This field is readonly once set
	pub reserved: Balance,
	/// Status
	pub status: WorkerStatus,
	/// Name identifier of the computer worker's implementation
	pub impl_name: WorkerImplName,
	/// Version of the computer worker's implementation
	/// Not the public version exposed to end users,
	/// Impl version is a sequential number that space and use friendly
	pub impl_version: WorkerImplVersion,
	/// Attestation method,
	/// This field is readonly once set
	pub attestation_method: Option<AttestationMethod>,
	/// A block number of when the worker refresh its attestation.
	/// It may be 0 in case the worker hasn't submit
	pub attested_at: BlockNumber,
	// log attestation report timestamp?
}

#[derive(Encode, Decode, MaxEncodedLen, TypeInfo, RuntimeDebug, Copy, Clone, PartialEq, Eq)]
pub enum FlipFlopStage {
	Flip,
	Flop,
	FlipToFlop,
	FlopToFlip,
}

impl Default for FlipFlopStage {
	fn default() -> Self {
		FlipFlopStage::Flip
	}
}

#[derive(Encode, Decode, MaxEncodedLen, TypeInfo, RuntimeDebug, Clone, PartialEq, Eq)]
pub struct WorkerImplPermission {
	pub oldest_version: WorkerImplVersion,
	pub latest_version: WorkerImplVersion,
	pub blocked_versions: BoundedVec<WorkerImplVersion, ConstU32<6>>,
}
impl Default for WorkerImplPermission {
	fn default() -> Self {
		Self {
			oldest_version: 1,
			latest_version: 1,
			blocked_versions: BoundedVec::<WorkerImplVersion, ConstU32<6>>::default(),
		}
	}
}

#[derive(Encode, Decode, TypeInfo, RuntimeDebug, Clone, PartialEq, Eq)]
pub enum OfflineReason {
	Graceful,
	Forced,
	Unresponsive,
	AttestationExpired,
	WorkerImplBlocked,
	InsufficientReservedFunds,
	Other(Option<Vec<u8>>),
}
